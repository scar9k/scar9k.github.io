{"meta":{"title":"scar9k's blog","subtitle":"һ��ѧǰ�˵Ĵ���","description":"scar9k's blog","author":"scar9k","url":"scar9k.github.io"},"pages":[],"posts":[{"title":"window.onload相关","slug":"onload","date":"2017-07-21T13:02:08.000Z","updated":"2017-09-05T12:53:13.834Z","comments":true,"path":"2017/07/21/onload/","link":"","permalink":"scar9k.github.io/2017/07/21/onload/","excerpt":"","text":"网页的有些函数必须在用户使用前提前加载才能正确地执行。如果要让函数在页面加载时执行，我们可以使用onload函数。1window.onload = functionname 如有多个函数需要在页面加载时，如果把他们依次12window.onload = function1window.onload = function2 实际执行时会只执行最后的那条指令。 解决方法112345window.onload =funtion()&#123;function1();function2();...&#125; 解决方法2使用addLoadEvent()12addLoadEvent(function1);addLoadEvent(function2);","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"scar9k.github.io/tags/前端/"},{"name":"DOM","slug":"DOM","permalink":"scar9k.github.io/tags/DOM/"}]},{"title":"childNodes , nodeType , nodeValue","slug":"childnodes","date":"2017-07-21T12:22:50.000Z","updated":"2017-09-06T03:59:06.130Z","comments":true,"path":"2017/07/21/childnodes/","link":"","permalink":"scar9k.github.io/2017/07/21/childnodes/","excerpt":"","text":"原生DOM中的childNodes,nodeType,nodeValuechildNodeschildNodes属性是包含某一种元素的所有子元素的数组，可以用于获取任意一种元素的所有子元素。 element.childNodes 比如，如果我们要吧某个文档内的所有的子元素全部检索出来，可以使用 123456var body_elems = getElementsByTagName(\"body\")[0]/**0指的是文档搜索起始点，因为一个文档body元素只有一个所以为0**/body_elems.childNodes 如果测试该数组的length会发现有很多的子元素，因为文档树的节点类型并非元素节点一种。 甚至空格之类的每一样东西都是一个节点。 nodeTypenodeType可以获取元素的类型 12body_elems.nodeType 得到的结果是1 nodeType有12种可取值 元素节点的值是 1 属性节点的值是 2 文本节点的值是 3 nodeValuenodeValue可以用于获取和修改一个节点的值 而在使用nodeValue获取一个对象时，得到的并不是对象的文本。 比如有id=description的段落 1234var description = document.getElementById(\"description\")alert (description.nodeValue) 得到的值是null，因为这指向的对象是一个段落，而不是段落中的文本。 firstChild和lastChild我们可以使用childNode 或是firstChild和lastChild 1234description.childnotes[0].nodeValuedescription.firstchild.nodeValue 可以达到同样的效果","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"scar9k.github.io/tags/前端/"},{"name":"DOM","slug":"DOM","permalink":"scar9k.github.io/tags/DOM/"}]},{"title":"初识DOM","slug":"DOM","date":"2017-07-19T12:04:17.000Z","updated":"2017-09-06T04:00:24.420Z","comments":true,"path":"2017/07/19/DOM/","link":"","permalink":"scar9k.github.io/2017/07/19/DOM/","excerpt":"","text":"什么是DOM？DOM是Document Object Model（文档对象模型）DOM是一种API(应用编程接口)W3C对DOM的定义是：“一个与系统平台和编程语言无关的接口，程序和脚本可以通过这个接口动态地访问和修改文档的内容、结构、样式。”当创建了一个网页并把他加载到Web浏览器中，DOM将编写的网页文档转换成了一个文档对象。 对象JavaScript的对象可以分为三种类型。 用户定义对象（user-defined object）：自己创建的对象。内建对象（native object）：内建在JavaScript语言中的对象。宿主对象（host object）：由浏览器提供的对象。 模型用简单点的方法说，DOM将网页转变成一个对象模型，而这个模型就像一个树形的族谱。用parent（父）、child（子）、sibling（兄弟）来表示家族的成员。例如 html文件是整个家族的根源的话，它可以分为 head 分支和 body 分支，那么 head 中的meta 和 title 就是兄弟关系而 head 就是它的 父辈。把这些元素看成点连起来，我们就可以把一个网络想象成由各种各样的节点连接而成的。 获取元素节点getElementById获取ID属性值的节点。getElementsByTagName获取某个标签的所有节点，由单复数可以看出，该方法返回的是一个对象数组。getElementsByClassName获取同一Class（类）的元素。H5标准支持这种方法，在老的浏览器环境中可以通过函数实现相同功能。1234567891011121314function getElementsByClassName(node,classname)/**node为搜索的起点，class为类名**/if(node.getElementsByClassName)&#123;ruturn node.getElementsByClassname/**原有方法有效使用原有方法**/&#125;else&#123;var results = new Array();/**定义一个“结果”为新数组**/var elems = node.getElementsByTagName(\"*\");/**把所有元素提取到elems**/for ( var i=0; i&lt;elems.length ; i++ ) &#123; if (elems[i].classname.indexof(classname) !=-1) results[results.length] = elems[i]; /**输出所有的相应classname的元素到results*/ &#125; &#125;return results; &#125;&#125; 获取后设置属性getAttribute获取指定的属性名的属性值setAttribute修改属性节点的值 值得注意的是；通过这种方法修改属性的值后，通过浏览器查看源代码仍然是改变前的值。DOM的工作模式是先加载文档的静态内容，再动态刷新。如此而来就不需要通过刷新浏览器页面来看到改变的内容了。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"scar9k.github.io/tags/前端/"},{"name":"DOM","slug":"DOM","permalink":"scar9k.github.io/tags/DOM/"}]},{"title":"关于br在html5中的写法","slug":"br","date":"2017-07-15T02:36:26.000Z","updated":"2017-09-05T13:31:42.702Z","comments":true,"path":"2017/07/15/br/","link":"","permalink":"scar9k.github.io/2017/07/15/br/","excerpt":"","text":"from 知乎&lt;br&gt;是HTML写法。&lt;br/&gt;是XHTML1.1的写法，也是XML写法。&lt;br /&gt;是XHTML为兼容HTML的写法，也是XML写法。因为HTML5兼容XHTML写法，所以三种都可以使用，没有区别。如果要省一到二个字节的文件大小，使用第一种。如果要方便地转成XML而且也要省一个字节的文件大小，使用第二种。如要要方便地转成XML而且要兼容老的浏览器，使用第三种。因为HTML是SGML的子集，SGML允许标签没有结束标签，而换行符元素正好不需要内嵌元素，也就不需要结束标签。所以在HTML中，应该写成&lt;br&gt;。因为XHTML是XML的子集，在XML中，标签必须要有结束标签。所以在XHTML中只写&lt;br&gt;是不符合语法的，必须写成&lt;br&gt;&lt;/br&gt;或简写成&lt;br/&gt;。而在XHTML的发展过程中，要做到兼容旧的HTML浏览器。而旧的HTML浏览器不理解（错误理解）这两种写法，对于第一种写法，某些浏览器估计会理解成两个&lt;br&gt;标签（我没有资料证明这一点），对于第二种写法，某些浏览器会理解成一个叫”br/“的标签。所以在兼容HTML的XHTML中我们通常把它写成&lt;br /&gt;，这样在HTML解析中会理解成有一个叫”/“的属性的”br”标签，在XML解析中仍然会理解成&lt;br&gt;&lt;/br&gt;的简写，达到了两全其美的效果。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"scar9k.github.io/tags/前端/"},{"name":"转载","slug":"转载","permalink":"scar9k.github.io/tags/转载/"}]}]}